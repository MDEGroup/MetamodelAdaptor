pre {
"$> Start migration...\n".println();
}

post {
"$> Migration completed.\n".println();
}
[%
// scorri le modifiche nel comparatore
for (comp in Comparison.allInstances()) {	
	"--- List of changes ---".println();	
	comp.matchedResources.leftURI.println('Left: ');
	comp.matchedResources.rightURI.println('Right: ');
	"Right -> Left".println('Evolution: ');
	
	if ( System.user.confirm("Are you ready to proceed?") ) {	
	
		var elementsChanging = DSCreate();
		
		// exploring changes in deep mode
		for (el in comp.matches)
			explore(el, comp, elementsChanging);
			
		// fixed Code
		CLS_LIST_METHOD();
	}
	else "Interrupted!".println();	
}

// EXPLORING CHANGES

operation explore(el: Any, comp: Any, elChanging: Map) {

	// setting source and destination models
	var source = el.right;
	var dest = el.left;	
	
	// inspecting PATTERNS of differences	
	
	// PACKAGES
	if ( isPackageMatch(el) ) {
				
		// Identifying Packages
		"Exploring package changes:".println("\n\t");		
		source.println("Source: ");
		dest.println("Destination: ");
		
		// Explore the package changes
		operatePackDiff(el, elChanging);
		
		// Explore changes in the package elements			
		if (not el.submatches.isEmpty())
			for (subEl in el.submatches) 
				explore(subEl, comp, elChanging);
	}
	
	// CLASSES
	else if ( isClassMatch(el) ) {
			
		
		// Identifying Class
		("Class [ " + classIdentification(source, dest) + " ]").println("\n\t");
		
		// Explore the class changes
		operateClassDiff(source, el, elChanging);		
		
		// write class rule (head)
		writeDownClassHeadRule( source, dest );
		
		// Explore changes in the class elements			
		if (not el.submatches.isEmpty())
			for (subEl in el.submatches) 
				explore(subEl, comp, elChanging);
				
		// write class rule (foot)
		writeDownClassFootRule( source, dest );
				
		"\t--\t--\t--".println(); 	
	}
	
	// ATTRIBUTES
	else if ( isAttributeMatch(el) ) {
		
		// Identifying Attribute and changes
		if (dest <> null)			
			operateAttributeDiff(source, dest, el, elChanging);
	}
	
	// REFERENCES
	else if ( isReferenceMatch(el) ) {
		
		// Identifying Reference and changes
		if (dest <> null)			
			operateReferenceDiff(source, dest, el, elChanging);		
	}
	
	// ERRORE!
	else {
		"I can't recognise what is changed!".println("!!!!!!");
	}
}

// UTILITY
operation classIdentification(source, dest): String {
	if (dest <> null)
		if (dest.eContainer() <> null)
			return dest.name + ' @ ' + dest.eContainer().name;
		else return dest.name;
	else if (source <> null)
			if (source.eContainer() <> null)
				return source.name + ' @ ' + source.eContainer().name;
			else return source.name;
	else return 'no name';
}

operation getUndeletedClassName(source, dest): String {
	if (dest <> null)
		return dest.name;	
	else return '';
}

// DATATYPE IDENTIFY
operation isIntegerAttribute(attr: Any): Boolean {
	return attr.getEType().name == 'EInt';
}

operation isFloatAttribute(attr: Any): Boolean {
	return attr.getEType().name == 'EFloat';
}

operation isCharAttribute(attr: Any): Boolean {
	return attr.getEType().name == 'EChar';
}

operation isStringAttribute(attr: Any): Boolean {
	return attr.getEType().name == 'EString';
}

// DATA STRUCTURE

/* 
			Data structure to sign elements changing
		
			elementsChanging [Map] -> [{'class', 'attribute', 'reference'} -> list]
						
			list [Map] -> [{'add', 'delete', 'move'} -> Sequence]
			
		*/
		
operation DSCreate(): Map {
	var ris = new Map;
	
	// Return new empty unstructured data structure	
	return ris;
}

// NB. The creation for datastructure is Lazy, so what is used is created!

// Get Level 1
operation Map DSgetClasses(): Map {
	if ( self.get('class') == null ) self.put('class', new Map);	
	return self.get('class');
}

operation Map DSgetAttributes(): Map {
	if ( self.get('attribute') == null ) self.put('attribute', new Map);	
	return self.get('attribute');
}

operation Map DSgetReferences(): Map {
	if ( self.get('reference') == null ) self.put('reference', new Map);	
	return self.get('reference');
}

// Get Level 2 - Deleted
operation Map DSgetDeleted(): Sequence {
	if ( self.get('delete') == null ) self.put('delete', new Sequence);
	return self.get('delete');
}

operation Map DSgetMoved(): Sequence {
	if ( self.get('move') == null ) self.put('move', new Sequence);
	return self.get('move');
}

operation Map DSgetAdded(): Sequence {
	if ( self.get('add') == null ) self.put('add', new Sequence);
	return self.get('add');
}

// Add Level 2 - Deleted
operation Map DSaddDeletedClass(cl: Any) {
	self.DSgetClasses().DSgetDeleted().add(cl);
}

operation Map DSaddDeletedAttribute(attr: Any) {
	self.DSgetAttributes().DSgetDeleted().add(attr);
}

operation Map DSaddDeletedReference(ref: Any) {
	self.DSgetReferences().DSgetDeleted().add(ref);
}

// Add Level 2 - Moved
operation Map DSaddMovedAttribute(attr: Any) {
	self.DSgetAttributes().DSgetMoved().add(attr);
}

operation Map DSaddMovedReference(ref: Any) {
	self.DSgetReferences().DSgetMoved().add(ref);
}

// Add Level 2 - Added
operation Map DSaddAddedAttribute(attr: Any) {
	self.DSgetAttributes().DSgetAdded().add(attr);
}

operation Map DSaddAddedReference(ref: Any) {
	self.DSgetReferences().DSgetAdded().add(ref);
}

// Check Level 2 - Deletion
operation Map DSisDeletedClass(cl: Any): Boolean {
	return ( self.DSgetClasses().DSgetDeleted().selectOne(x: Any | x == cl) <> null );
}

operation Map DSisDeletedAttribute(attr: Any): Boolean {
	return ( self.DSgetAttributes().DSgetDeleted().selectOne(x: Any | x == attr) <> null );
}

operation Map DSisDeletedReference(ref: Any): Boolean {
	return ( self.DSgetReferences().DSgetDeleted().selectOne(x: Any | x == ref) <> null );
}

// Check Level 2 - Moving
operation Map DSisMovedAttribute(attr: Any): Boolean {
	return ( self.DSgetAttributes().DSgetMoved().selectOne(x: Any | x == attr) <> null );
}

operation Map DSisMovedReference(ref: Any): Boolean {
	return ( self.DSgetReferences().DSgetMoved().selectOne(x: Any | x == ref) <> null );
}

// Check Level 2 - Adding
operation Map DSisAddedAttribute(attr: Any): Boolean {
	return ( self.DSgetAttributes().DSgetAdded().selectOne(x: Any | x == attr) <> null );
}

operation Map DSisAddedReference(ref: Any): Boolean {
	return ( self.DSgetReferences().DSgetAdded().selectOne(x: Any | x == ref) <> null );
}


// Other Checks
operation Any isAddedElement(): Boolean {
	return ( self.kind.asString() == 'ADD' );
}

operation Any isDeletedElement(): Boolean {
	return ( self.kind.asString() == 'DELETE' );
}

operation Any isMovedElement(): Boolean {	
	return ( self.kind.asString() == 'MOVE' );
}

operation Any isClassElement(): Boolean {
	return ( self.value.type().name.asString() == 'EClass');
}

operation Any isAttributeElement(): Boolean {
	return ( self.value.type().name.asString() == 'EAttribute');
}

operation Any isReferenceElement(): Boolean {
	return ( self.value.type().name.asString() == 'EReference');
}

// CHECKING TYPE OF ELEMENT CHANGED
operation isPackageMatch(el: Any): Boolean {
	if ( el.left <> null ) return ( el.left.type().name == 'EPackage' );
	else if ( el.right <> null ) return ( el.right.type().name == 'EPackage' );
}

operation isClassMatch(el: Any): Boolean {
	if ( el.left <> null ) return ( el.left.type().name == 'EClass' );
	else if ( el.right <> null ) return ( el.right.type().name == 'EClass' );
}

operation isAttributeMatch(el: Any): Boolean {
	if ( el.left <> null ) return ( el.left.type().name == 'EAttribute' );
	else if ( el.right <> null ) return ( el.right.type().name == 'EAttribute' );
}

operation isReferenceMatch(el: Any): Boolean {
	if ( el.left <> null ) return ( el.left.type().name == 'EReference' );
	else if ( el.right <> null ) return ( el.right.type().name == 'EReference' );
}

// CHECKING CHANGES

// ... package
operation operatePackDiff(el: Any, elChanging: Map) {
	for (x in el.differences)
		switch ( x.type().name ) {			
			case 'ReferenceChange': 
				x.value.name.println(x.kind + ' Reference ' + x.value.type().name + ' : ');
				if ( x.isDeletedElement() and x.isClassElement() )
					elChanging.DSaddDeletedClass(x.value);
			
			case 'AttributeChange' : 
				x.value.println(x.kind + ' Attribute ' + x.attribute.name + ' : ');
			
			default : 
				x.value.println(x.kind + ' Generic: ');
		}
}

// ...classes
operation operateClassDiff(source, el: Any, elChanging: Map) {
	
	// Ignore deleted classes
	if ( not elChanging.DSisDeletedClass(source) ) {	
	
		// changes
		for (x in el.differences) {
			switch ( x.type().name ) {
				case 'ReferenceChange' :
					if ( x.isAttributeElement() ) {
						if ( x.isMovedElement() ) {
							elChanging.DSaddMovedAttribute(x.value);							
						}	
						else if ( x.isAddedElement() ) {
							elChanging.DSaddAddedAttribute(x.value);
						}					
						else if ( x.isDeletedElement() ) {
							elChanging.DSaddDeletedAttribute(x.value);
							(x.value.name + ' ( so ignored )').println('DELETED Attribute ' + x.value.type().name + ' : ');			
						}
					}
					else if ( x.isReferenceElement() ) {
						if ( x.isMovedElement() ) {
							elChanging.DSaddMovedReference(x.value);							
						}
						else if ( x.isAddedElement() ) {
							elChanging.DSaddAddedReference(x.value);
						}						
						else if ( x.isDeletedElement() ) {
							elChanging.DSaddDeletedReference(x.value);
							(x.value.name + ' ( so ignored )').println('DELETED Reference ' + x.value.type().name + ' : ');			
						}
					}					
				
				case 'AttributeChange' :
					
							
					
				default : 
					x.value.println(x.kind + ' Generic: ');
			}			
		}
	}
	else "Ignored DELETED class!".println();
}


// ... attributes
operation operateAttributeDiff(source, dest, el: Any, elChanging: Map) {

	// operate Attribute adaptation	
	if ( elChanging.DSisMovedAttribute(dest) ) {
		(dest.name + ' > ' + dest.getEType().name).println("MOVED ATTRIBUTE: ");
		writeDownAttributeMove( source, dest );
	}
	else if ( elChanging.DSisAddedAttribute(dest) ) {
		(dest.name + ' > ' + dest.getEType().name).println("ADDED ATTRIBUTE: ");
		writeDownAttributeAdd( source, dest );
	}
	else {
		(dest.name + ' > ' + dest.getEType().name).println("COPIED ATTRIBUTE: ");
		writeDownAttributeCopy( source, dest );
	}	
}

// ... references
operation operateReferenceDiff(source, dest, el: Any, elChanging: Map) {

	// operate Reference adaptation
	if ( elChanging.DSisMovedReference(dest) ) {
		(dest.name + ' > ' + dest.getEType().name).println("MOVED REFERENCE: ");
		writeDownReferenceMove( source, dest );
	}
	else if ( elChanging.DSisAddedReference(dest) ) {
		(dest.name + ' > ' + dest.getEType().name).println("ADD REFERENCE: ");
		writeDownReferenceAdd( source, dest );
	}
	else {
		(dest.name + ' > ' + dest.getEType().name).println("COPIED REFERENCE: ");
		writeDownReferenceCopy( source, dest );
	}
		
}

// APPLYING CHANGES

// ... package

// ... classes
operation writeDownClassHeadRule(source, dest) {
	var cName = getUndeletedClassName(source, dest);	
	if ( cName <> '' ) {
%]
	
	// Adapting class '[%=cName%]' @ package '[%=dest.eContainer().name%]'
	rule Adapt_[%=cName%]
	transform s: Input![%=cName%]
	to d: Output![%=cName%] {
	
		var clChoiceList = cListCl();
		var classData1 = clChoiceList.selectOne(c:Input![%=cName%] | true);
		
		var sorgList = Input![%=cName%].allInstances();
		var sorgCh;
	
[%
	}
}

operation writeDownClassFootRule(source, dest) {
	if ( getUndeletedClassName(source, dest) <> '' ) {
%]
	}
[%
	}
}

// ... attributes
operation writeDownAttributeCopy(source, dest) {
%]
		d.[%=dest.name%] = s.[%=source.name%]; 
[%
}

operation writeDownAttributeAdd( source, dest ) {
	if ( isIntegerAttribute(dest) ) {
%]
		d.[%=dest.name%] = System.user.promptInteger('Insert the new ( integer ) value for "[%=dest.name%]" @ class "' + classData1 + '":'); 
[%
	}
	else if ( isFloatAttribute(dest) ) {
%]
		d.[%=dest.name%] = System.user.promptReal('Insert the new ( float ) value for "[%=dest.name%]" @ class "' + classData1 + '":');
[%
	}
	else if ( isCharAttribute(dest) ) {
%]
		d.[%=dest.name%] = System.user.prompt('Insert the new ( char ) value for "[%=dest.name%]" @ class "' + classData1 + '":').charAt(0);
[%
	}
	else if ( isStringAttribute(dest) ) {
%]
		d.[%=dest.name%] = System.user.prompt('Insert the new ( string ) value for "[%=dest.name%]" @ class "' + classData1 + '":');
[%
	}
}

operation writeDownAttributeMove( source, dest ) {
%]
			sorgCh = System.user.choose('Choose the source Class for "[%=dest.name%]" @ Class "' + s + '":', sorgList);
		d.[%=dest.name%] = sorgCh.[%=source.name%]; 
[%
}

// ... references
operation writeDownReferenceCopy(source, dest) {
%]
		d.[%=dest.name%] = s.[%=source.name%].equivalent(); 
[%
}

operation writeDownReferenceAdd( source, dest ) {
%]
		d.[%=dest.name%] = System.user.choose('Choose the reference for "[%=dest.name%]" @ Class "' + classData1 + '":', clChoiceList ).equivalent();
[%
}

operation writeDownReferenceMove( source, dest ) {
%]
			sorgCh = System.user.choose('Choose the source Class for "[%=dest.name%]" @ Class "' + s + '":', sorgList);
		d.[%=dest.name%] = sorgCh.[%=source.name%].equivalent(); 
[%
}

// fixed ETL Code
operation CLS_LIST_METHOD() {
%]

// List of all Input Classes
operation cListCl(): Sequence {	
	var clChoiceList = new Sequence;
	var listOfInClasses = Input.allInstances();	
	for (x in listOfInClasses)
		clChoiceList.add(x);
	return clChoiceList;
}
[%
}

%]