pre {
"$> Avvio trasformazione\n".println();
}

post {
"$> Trasformazione completata\n".println();
}
[%

// scorri le modifiche nel comparatore
for (comp in Comparison.allInstances()) {	
	"--- Elenco cambiamenti ---".println();	
	var listaAggiunti = new Map;
	var listaRimossi = new Map;
	var listaUguali = new Map;	
	
	// esplorazione delle modifiche e copia classi uguali
	for (u in comp.matches)
		esplora(u, listaAggiunti, listaRimossi, listaUguali);
		
	// generazione classi modificate
	regolaNuoveClassi(listaAggiunti, listaUguali);	
	regolaCopiaClassi(listaUguali);
}

// Esplorazione corrispondenze fra i due metamodelli
operation esplora(m: Match, a: Map, r: Map, u: Map){

	if (not m.submatches.isEmpty())
		for (sub in m.submatches) esplora(sub, a, r, u);
		
	var sorg = m.right;
	var dest = m.left;	
	
	// elemento non modificato	
	if (m.differences.isEmpty()) {
		//( sorg.type().name + "[ " + sorg.name + " ] UGUALE @ " + 
		//  sorg.eContainer.type().name + "[ " + sorg.eContainer().name + " ] " ).println();
		
		// Le classi invariate vengono copiate da regole semplici
		if (sorg.type().name == "EClass") aggiungiCoda(u, CLS_EQU(), sorg.name);
		
		// Gli altri elementi invariati vengono aggiunti alla coda di copia
		else {
			if (sorg.eContainer().isDefined()) aggiungiCoda(a, sorg.eContainer().name, sorg);		
		}			
	}
	
	// elemento modificato
	else {	
		"".println();								
		
		// Caso 1: elemento aggiunto
		if ((sorg == null) and (dest <> null)){
			
			// Log modifica
			( dest.type().name + "[ " + dest.name + " ] AGGIUNTO @ " + 
			  dest.eContainer.type().name + "[ " + dest.eContainer().name + " ] " ).println();
			  
			// Traccia modifica
			// Gli elementi aggiunti vengono messi in coda di copia
			aggiungiCoda(a, dest.eContainer().name, dest);					
		}
		
		// Caso 2: elemento cancellato
		else if ((sorg <> null) and (dest == null)){
			
			// Log modifica
			( sorg.type().name + "[ " + sorg.name + " ] RIMOSSO @ " + 
			  sorg.eContainer.type().name + "[ " + sorg.eContainer().name + " ] " ).println();
			  
			// Traccia modifica
			// Gli elementi rimossi vengono messi in coda di cancellazione
			aggiungiCoda(r, sorg.eContainer().name, sorg);			
		}
		
		// Caso 3: elemento spostato
		else if (sorg.eContainer() <> dest.eContainer()) {
		
			// Log modifica
			( sorg.type().name + "[ " + sorg.name + " ] SPOSTATO").println(); 
			  ("Da: " + sorg.eContainer.type().name + "[ " + sorg.eContainer().name + " ] " ).println();			  
			  ("A: " + dest.eContainer.type().name + "[ " + dest.eContainer().name + " ] " ).println();
			
			// Traccia modifica
			// Gli elementi spostati vengono rimossi dalla sorgente...
			aggiungiCoda(r, sorg.eContainer().name, sorg);
						
			// ... e aggiunti alla destinazione
			aggiungiCoda(a, dest.eContainer().name, dest);						  
		}
		
		// Caso 4: elemento modificato
		else {
			
			// Log modifica 
			if (sorg.eContainer().isDefined())
				( sorg.type().name + "[ " + sorg.name + " ] MODIFICATO @ " + 
				  sorg.eContainer.type().name + "[ " + sorg.eContainer().name + " ] " ).println();
			else 
				( sorg.type().name + "[ " + sorg.name + " ] MODIFICATO").println();
			
			("Precedente: " + sorg).println();
			("Successivo: " + dest).println();
			
			// Traccia modifica
			// Gli elementi modificati vengono aggiunti alla coda di modifica
			if (sorg.eContainer().isDefined()) aggiungiCoda(a, dest.eContainer().name, dest);
		}
	/*
	// Debug	
	a.println();
	r.println();*/
	}
}

// aggiungi elemento ad una coda di operazioni
operation aggiungiCoda(coda: Map, k: Any, v: Any) {

	if (not coda.containsKey(k)) coda.put(k, new Sequence);
	coda.get(k).add(v);
}

// rimuovi elemento da una coda di operazioni
operation rimuoviCoda(coda: Map, k: Any, v: Any) {

	if (coda.containsKey(k)) coda.get(k).remove(v);
}

// Regole per la copia di classi invariate
operation regolaCopiaClassi(l1: Map) {	

	for (c in l1.get( CLS_EQU() )) {	
%]	
	// Copia di: [%=c%]	
	rule Invariato_[%=c%]
		transform s : Input![%=c%]
		to d: Output![%=c%] {
		}		
[%
	}
}

// Regole per trasformazioni classi con cambiamenti
operation regolaNuoveClassi(coda: Map, coda2: Map) {

	// raggruppa i cambiamenti per classi
	var classi = coda.keySet();	
	for (c in classi) {		
		rimuoviCoda(coda2, CLS_EQU(), c);
%]	
	// Modifica di: [%=c%] 
	rule Modificata_[%=c%]
		transform s: Input![%=c%]
		to d: Output![%=c%] {
		
[%	
			for (a in coda.get(c)) {
				if (a.type().name == 'EAttribute') {
%]			d.[%=a.name%] = ''; // viene chiesto all'utente un valore di inizializzazione
[%			}
				else if (a.type().name == 'EReference') {
%]			d.[%=a.name%] = s.[%=a.name%].equivalent();
[%
				}
			}
%]
		}
[%			
	}
}

// Dichiarazioni di espressioni costanti
operation CLS_EQU() { return 'classiUguali';}

%]